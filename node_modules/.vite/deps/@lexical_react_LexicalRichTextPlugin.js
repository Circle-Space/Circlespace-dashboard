import {
  require_react_dom
} from "./chunk-JFI3BA7V.js";
import {
  registerRichText
} from "./chunk-2LOZQT7X.js";
import {
  useLexicalComposerContext
} from "./chunk-3SH4SKS3.js";
import {
  require_react
} from "./chunk-EPE4LH7V.js";
import {
  mergeRegister
} from "./chunk-4OYVJ26O.js";
import "./chunk-YVRCHDR7.js";
import {
  $getRoot,
  $getSelection,
  $isDecoratorNode,
  $isElementNode,
  $isParagraphNode,
  $isRangeSelection,
  $isTextNode
} from "./chunk-YRFTX4RL.js";
import {
  __toESM,
  init_shim
} from "./chunk-4IB4DCYP.js";

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs
init_shim();

// node_modules/@lexical/react/useLexicalEditable.dev.mjs
init_shim();
var import_react = __toESM(require_react(), 1);
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl = CAN_USE_DOM ? import_react.useLayoutEffect : import_react.useEffect;
var useLayoutEffect = useLayoutEffectImpl;
function useLexicalSubscription(subscription2) {
  const [editor] = useLexicalComposerContext();
  const initializedSubscription = (0, import_react.useMemo)(() => subscription2(editor), [editor, subscription2]);
  const valueRef = (0, import_react.useRef)(initializedSubscription.initialValueFn());
  const [value, setValue] = (0, import_react.useState)(valueRef.current);
  useLayoutEffect(() => {
    const {
      initialValueFn,
      subscribe
    } = initializedSubscription;
    const currentValue = initialValueFn();
    if (valueRef.current !== currentValue) {
      valueRef.current = currentValue;
      setValue(currentValue);
    }
    return subscribe((newValue) => {
      valueRef.current = newValue;
      setValue(newValue);
    });
  }, [initializedSubscription, subscription2]);
  return value;
}
function subscription(editor) {
  return {
    initialValueFn: () => editor.isEditable(),
    subscribe: (callback) => {
      return editor.registerEditableListener(callback);
    }
  };
}
function useLexicalEditable() {
  return useLexicalSubscription(subscription);
}

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@lexical/text/LexicalText.dev.mjs
init_shim();
function $rootTextContent() {
  const root = $getRoot();
  return root.getTextContent();
}
function $isRootTextContentEmpty(isEditorComposing, trim = true) {
  if (isEditorComposing) {
    return false;
  }
  let text = $rootTextContent();
  if (trim) {
    text = text.trim();
  }
  return text === "";
}
function $canShowPlaceholder(isComposing) {
  if (!$isRootTextContentEmpty(isComposing, false)) {
    return false;
  }
  const root = $getRoot();
  const children = root.getChildren();
  const childrenLength = children.length;
  if (childrenLength > 1) {
    return false;
  }
  for (let i = 0; i < childrenLength; i++) {
    const topBlock = children[i];
    if ($isDecoratorNode(topBlock)) {
      return false;
    }
    if ($isElementNode(topBlock)) {
      if (!$isParagraphNode(topBlock)) {
        return false;
      }
      if (topBlock.__indent !== 0) {
        return false;
      }
      const topBlockChildren = topBlock.getChildren();
      const topBlockChildrenLength = topBlockChildren.length;
      for (let s = 0; s < topBlockChildrenLength; s++) {
        const child = topBlockChildren[i];
        if (!$isTextNode(child)) {
          return false;
        }
      }
    }
  }
  return true;
}
function $canShowPlaceholderCurry(isEditorComposing) {
  return () => $canShowPlaceholder(isEditorComposing);
}

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs
var import_react_dom = __toESM(require_react_dom(), 1);

// node_modules/@lexical/dragon/LexicalDragon.dev.mjs
init_shim();
function registerDragonSupport(editor) {
  const origin = window.location.origin;
  const handler = (event) => {
    if (event.origin !== origin) {
      return;
    }
    const rootElement = editor.getRootElement();
    if (document.activeElement !== rootElement) {
      return;
    }
    const data = event.data;
    if (typeof data === "string") {
      let parsedData;
      try {
        parsedData = JSON.parse(data);
      } catch (e) {
        return;
      }
      if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
        const payload = parsedData.payload;
        if (payload && payload.functionId === "makeChanges") {
          const args = payload.args;
          if (args) {
            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;
            editor.update(() => {
              const selection = $getSelection();
              if ($isRangeSelection(selection)) {
                const anchor = selection.anchor;
                let anchorNode = anchor.getNode();
                let setSelStart = 0;
                let setSelEnd = 0;
                if ($isTextNode(anchorNode)) {
                  if (elementStart >= 0 && elementLength >= 0) {
                    setSelStart = elementStart;
                    setSelEnd = elementStart + elementLength;
                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                  }
                }
                if (setSelStart !== setSelEnd || text !== "") {
                  selection.insertRawText(text);
                  anchorNode = anchor.getNode();
                }
                if ($isTextNode(anchorNode)) {
                  setSelStart = selStart;
                  setSelEnd = selStart + selLength;
                  const anchorNodeTextLength = anchorNode.getTextContentSize();
                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                }
                event.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  window.addEventListener("message", handler, true);
  return () => {
    window.removeEventListener("message", handler, true);
  };
}

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs
var CAN_USE_DOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl2 = CAN_USE_DOM2 ? import_react2.useLayoutEffect : import_react2.useEffect;
var useLayoutEffect2 = useLayoutEffectImpl2;
function canShowPlaceholderFromCurrentEditorState(editor) {
  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));
  return currentCanShowPlaceholder;
}
function useCanShowPlaceholder(editor) {
  const [canShowPlaceholder, setCanShowPlaceholder] = (0, import_react2.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));
  useLayoutEffect2(() => {
    function resetCanShowPlaceholder() {
      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
      setCanShowPlaceholder(currentCanShowPlaceholder);
    }
    resetCanShowPlaceholder();
    return mergeRegister(editor.registerUpdateListener(() => {
      resetCanShowPlaceholder();
    }), editor.registerEditableListener(() => {
      resetCanShowPlaceholder();
    }));
  }, [editor]);
  return canShowPlaceholder;
}
function useDecorators(editor, ErrorBoundary) {
  const [decorators, setDecorators] = (0, import_react2.useState)(() => editor.getDecorators());
  useLayoutEffect2(() => {
    return editor.registerDecoratorListener((nextDecorators) => {
      (0, import_react_dom.flushSync)(() => {
        setDecorators(nextDecorators);
      });
    });
  }, [editor]);
  (0, import_react2.useEffect)(() => {
    setDecorators(editor.getDecorators());
  }, [editor]);
  return (0, import_react2.useMemo)(() => {
    const decoratedPortals = [];
    const decoratorKeys = Object.keys(decorators);
    for (let i = 0; i < decoratorKeys.length; i++) {
      const nodeKey = decoratorKeys[i];
      const reactDecorator = React.createElement(ErrorBoundary, {
        onError: (e) => editor._onError(e)
      }, React.createElement(import_react2.Suspense, {
        fallback: null
      }, decorators[nodeKey]));
      const element = editor.getElementByKey(nodeKey);
      if (element !== null) {
        decoratedPortals.push((0, import_react_dom.createPortal)(reactDecorator, element, nodeKey));
      }
    }
    return decoratedPortals;
  }, [ErrorBoundary, decorators, editor]);
}
function useRichTextSetup(editor) {
  useLayoutEffect2(() => {
    return mergeRegister(registerRichText(editor), registerDragonSupport(editor));
  }, [editor]);
}
function RichTextPlugin({
  contentEditable,
  placeholder,
  ErrorBoundary
}) {
  const [editor] = useLexicalComposerContext();
  const decorators = useDecorators(editor, ErrorBoundary);
  useRichTextSetup(editor);
  return React.createElement(React.Fragment, null, contentEditable, React.createElement(Placeholder, {
    content: placeholder
  }), decorators);
}
function Placeholder({
  content
}) {
  const [editor] = useLexicalComposerContext();
  const showPlaceholder = useCanShowPlaceholder(editor);
  const editable = useLexicalEditable();
  if (!showPlaceholder) {
    return null;
  }
  if (typeof content === "function") {
    return content(editable);
  } else {
    return content;
  }
}
export {
  RichTextPlugin
};
//# sourceMappingURL=@lexical_react_LexicalRichTextPlugin.js.map
